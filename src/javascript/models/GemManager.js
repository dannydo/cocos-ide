// Generated by CoffeeScript PHP 1.3.1
(function() {
  var GemManager,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  GemManager = (function() {

    function GemManager(_arg) {
      var template, _ref, _ref1, _ref2;
      _ref = _arg != null ? _arg : {}, template = _ref.template, this.tileManager = _ref.tileManager, this.dropManager = _ref.dropManager;
      _ref2 = (_ref1 = this.tileManager, this.width = _ref1.width, this.height = _ref1.height, _ref1), this.rowMax = _ref2.rowMax, this.colMax = _ref2.colMax;
      if (template == null) {
        template = {};
      }
      this.gems = [];
      this.megaGems = [];
      this.newGems = [];
      this.damageGems = [];
      this._populateGems({
        template: template
      });
    }

    GemManager.prototype._populateGems = function(_arg) {
      var colors, crowdedNeighbour, forward, gem, index, position, previous, template, type, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _results;
      template = _arg.template;
      this.gems = [];
      _results = [];
      for (index = _i = 0, _ref = this.width * this.height; 0 <= _ref ? _i < _ref : _i > _ref; index = 0 <= _ref ? ++_i : --_i) {
        position = this.positionFromIndex({
          index: index
        });
        previous = {
          col: this.gems[position.index - this.height],
          row: this.gems[position.index - 1]
        };
        colors = this.dropManager.getColors();
        if (this.tileManager.tiles[position.index].isGemable) {
          crowdedNeighbour = {
            col: position.col && previous.col.neighbour.col.length > 1,
            row: position.row && previous.row.neighbour.row.length > 1
          };
          forward = {
            col: template[position.index + this.height],
            row: template[position.index + 1]
          };
          _ref1 = ['col', 'row'];
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            type = _ref1[_j];
            if (crowdedNeighbour[type] && (_ref2 = previous[type].color, __indexOf.call(colors, _ref2) >= 0)) {
              $Model.array.remove(colors, previous[type].color);
            }
            if (position[type] < this.height && forward[type] && forward[type].color === previous[type].color && (_ref3 = forward[type].color, __indexOf.call(colors, _ref3) >= 0)) {
              $Model.array.remove(colors, forward[type].color);
            }
          }
        } else {
          colors = [0];
        }
        gem = this.gems[position.index] = this.dropManager.drop({
          position: position,
          colors: colors,
          gemParamaters: template[position.index]
        });
        _results.push(this.joinNeighbour(gem));
      }
      return _results;
    };

    GemManager.prototype.translate = function(_arg) {
      var alternativeType, amount, col, gem, offset, position, range, row, tileRange, type, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _results;
      type = _arg.type, position = _arg.position, amount = _arg.amount;
      if (__indexOf.call($Config.types, type) < 0) {
        return;
      }
      alternativeType = $Config.alternativeType(type);
      this.previousTranslation = {
        type: type,
        alternativeType: alternativeType,
        position: position,
        amount: amount
      };
      range = {
        row: [position.row],
        col: [position.col]
      };
      tileRange = this.tileManager.tiles[position.index].range[type];
      range[type] = (function() {
        _results = [];
        for (var _i = _ref = tileRange.start, _ref1 = tileRange.end; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      this.mobileGem = {
        col: [],
        row: [],
        gems: []
      };
      _ref2 = range.col;
      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
        col = _ref2[_j];
        _ref3 = range.row;
        for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
          row = _ref3[_k];
          position = this.positionFromColRow({
            col: col,
            row: row
          });
          gem = this.gems[position.index];
          if (gem.color || gem.combo) {
            this.mobileGem[type].push(position[type]);
            this.mobileGem.gems.push(gem);
          }
        }
      }
      this.mobileGem[alternativeType] = range[alternativeType];
      amount = (amount % this.mobileGem.gems.length + this.mobileGem.gems.length) % this.mobileGem.gems.length;
      if (amount === 0) {
        this.mobileGem.validMove = true;
        return this.mobileGem;
      }
      offset = amount - 1;
      _ref4 = this.mobileGem.col;
      for (_l = 0, _len2 = _ref4.length; _l < _len2; _l++) {
        col = _ref4[_l];
        _ref5 = this.mobileGem.row;
        for (_m = 0, _len3 = _ref5.length; _m < _len3; _m++) {
          row = _ref5[_m];
          position = this.positionFromColRow({
            col: col,
            row: row
          });
          offset = (offset + 1) % this.mobileGem.gems.length;
          gem = this.mobileGem.gems[offset];
          this.gems[position.index] = gem;
          gem.position = position;
        }
      }
      this.recalcuateNeighbours();
      this.mobileGem.validMove = false;
      _ref6 = this.mobileGem.gems;
      for (_n = 0, _len4 = _ref6.length; _n < _len4; _n++) {
        gem = _ref6[_n];
        _ref7 = $Config.types;
        for (_o = 0, _len5 = _ref7.length; _o < _len5; _o++) {
          type = _ref7[_o];
          if (gem.neighbour[type].length > 2) {
            this.mobileGem.validMove = true;
          }
        }
      }
      return this.mobileGem;
    };

    GemManager.prototype.destoryMatchGems = function() {
      var altType, comboGroup, comboGroups, comboIgnore, damageGems, gem, index, matches, neighbour, type, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      this._destoryGems = [];
      damageGems = [];
      matches = [];
      if (!(this.mobileGem != null)) {
        return this._destoryGems;
      }
      this._dropComboGems = [];
      comboIgnore = [];
      comboGroups = [];
      _ref = this.gems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gem = _ref[_i];
        if ((_ref1 = gem.position.index, __indexOf.call(comboIgnore, _ref1) < 0) && gem.neighbour.row.length > 2 && gem.neighbour.col.length > 2) {
          comboGroup = [];
          neighbour = {
            col: $Model.array.insertListUnique(comboGroup, gem.neighbour.col),
            row: $Model.array.insertListUnique(comboGroup, gem.neighbour.row)
          };
          while (neighbour.col.length > 0 && neighbour.row.length > 0) {
            _ref2 = $Config.types;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              type = _ref2[_j];
              altType = $Config.alternativeType(type);
              if (neighbour[type].length) {
                index = neighbour[type].pop();
                (_ref3 = neighbour[altType]).push.apply(_ref3, $Model.array.insertListUnique(comboGroup, this.gems[index].neighbour[altType]));
              }
            }
          }
          $Model.array.insertListUnique(comboIgnore, comboGroup);
          comboGroups.push(comboGroup);
        }
      }
      _ref4 = this.gems;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        gem = _ref4[_k];
        _ref5 = $Config.types;
        for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
          type = _ref5[_l];
          neighbour = gem.neighbour[type];
          if (neighbour.length > 2) {
            $Model.array.insertUnique(damageGems, gem);
          }
          if (neighbour.length > 3 && (_ref6 = gem.position.index, __indexOf.call(comboIgnore, _ref6) < 0)) {
            $Model.array.insertUnique(comboGroups, neighbour);
          }
        }
      }
      /*
      
              if @previousTranslation
                  {alternativeType, position} = @previousTranslation
                  
                  for rawCombo in rawCombos
                      for index in rawCombo
                          gem = @gems[index]
                          if gem.position[alternativeType] == position[alternativeType]
                              #TODO WHEN YOU Graphic are available change 2 to 3 to enable combo6
                              @_dropComboGems.push 
                                  index: gem.position.index
                                  combo_level: $Model.clamp(1, 2, rawCombo.length - 3)
              else 
                  for rawCombo in rawCombos
                      index = Math.floor(Math.random() * rawCombo.length)
                      #TODO WHEN YOU Graphic are available change 2 to 3 to enable combo6
                      @_dropComboGems.push 
                          index: rawCombo[index]
                          combo_level: $Model.clamp(1, 2, rawCombo.length - 3)
      */

      console.log(comboGroups);
      for (_m = 0, _len4 = damageGems.length; _m < _len4; _m++) {
        gem = damageGems[_m];
        gem.damage();
        if (gem.isDistoryed) {
          this._destoryGems.push(gem.position.index);
        }
      }
      delete this.previousTranslation;
      $Model.array.sort(this._destoryGems);
      return this._destoryGems;
    };

    GemManager.prototype.dropComboGems = function() {
      var combo_level, dropComboGems, index, position, _i, _len, _ref, _ref1;
      dropComboGems = [];
      _ref = this._dropComboGems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], index = _ref1.index, combo_level = _ref1.combo_level;
        $Model.array.remove(this._destoryGems, index);
        position = this.positionFromIndex({
          index: index
        });
        this.gems[position.index] = this.dropManager.drop({
          colors: [this.gems[position.index].color],
          position: position,
          gemParamaters: {
            combo: combo_level
          }
        });
        dropComboGems.push(position.index);
      }
      return dropComboGems;
    };

    GemManager.prototype.bubbleDestoryGems = function() {
      var DestoryGems, Row, bubbleColums, col, destoryGems, destoryPosition, drop_height, gem, index, normalGems, position, possibleRows, row, _i, _j, _k, _l, _len, _len1, _len2, _ref;
      this._bubbleGems = [];
      bubbleColums = {};
      destoryGems = [];
      _ref = this._destoryGems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        index = _ref[_i];
        destoryPosition = this.positionFromIndex({
          index: index
        });
        bubbleColums[destoryPosition.col] = destoryPosition.row;
      }
      for (col in bubbleColums) {
        Row = bubbleColums[col];
        col = col * 1;
        normalGems = [];
        DestoryGems = [];
        possibleRows = [];
        for (row = _j = Row; Row <= 0 ? _j <= 0 : _j >= 0; row = Row <= 0 ? ++_j : --_j) {
          position = this.positionFromColRow({
            col: col,
            row: row
          });
          gem = this.gems[position.index];
          if ((gem.color || gem.combo) && gem.isDistoryed === false) {
            normalGems.push(gem);
            possibleRows.push(row);
          } else if (gem.isDistoryed === true) {
            DestoryGems.push(gem);
            possibleRows.push(row);
          }
        }
        for (index = _k = 0, _len1 = normalGems.length; _k < _len1; index = ++_k) {
          gem = normalGems[index];
          position = this.positionFromColRow({
            col: col,
            row: possibleRows[index]
          });
          drop_height = position.index - gem.position.index;
          this.moveGem({
            gem: gem,
            position: position
          });
          this._bubbleGems.push([position.index, drop_height]);
        }
        for (index = _l = 0, _len2 = DestoryGems.length; _l < _len2; index = ++_l) {
          gem = DestoryGems[index];
          position = this.positionFromColRow({
            col: col,
            row: possibleRows[normalGems.length + index]
          });
          this.moveGem({
            gem: gem,
            position: position
          });
          destoryGems.push(position.index);
        }
      }
      this._destoryGems = destoryGems;
      return this._bubbleGems;
    };

    GemManager.prototype.dropNewGems = function() {
      var index, position, _i, _len, _ref;
      this.dropGems = this._destoryGems.splice(0, this._destoryGems.length);
      _ref = this.dropGems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        index = _ref[_i];
        position = this.positionFromIndex({
          index: index
        });
        this.gems[position.index] = this.dropManager.drop({
          position: position
        });
      }
      this.recalcuateNeighbours();
      return this.dropGems;
    };

    GemManager.prototype.recalcuateNeighbours = function() {
      var gem, _i, _len, _ref, _results;
      _ref = this.gems;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gem = _ref[_i];
        _results.push(this.joinNeighbour(gem));
      }
      return _results;
    };

    GemManager.prototype.positionFromIndex = function(_arg) {
      var index;
      index = _arg.index;
      return $Model.positionFromIndex({
        manager: this,
        index: index
      });
    };

    GemManager.prototype.positionFromColRow = function(_arg) {
      var col, row, _ref;
      _ref = _arg != null ? _arg : {}, col = _ref.col, row = _ref.row;
      return $Model.positionFromColRow({
        manager: this,
        col: col,
        row: row
      });
    };

    GemManager.prototype.moveGem = function(_arg) {
      var gem, position;
      gem = _arg.gem, position = _arg.position;
      this.gems[position.index] = gem;
      return gem.position = position;
    };

    GemManager.prototype.joinNeighbour = function(gem) {
      var position, previous, type, _i, _len, _ref, _results;
      position = gem.position;
      previous = {
        col: this.gems[position.index - this.height],
        row: this.gems[position.index - 1]
      };
      _ref = $Config.types;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        if (position[type] * 1 && previous[type].color === gem.color) {
          gem.neighbour[type] = previous[type].neighbour[type];
        } else {
          gem.neighbour[type] = [];
        }
        _results.push(gem.neighbour[type].push(position.index));
      }
      return _results;
    };

    GemManager.prototype.clone = function() {};

    return GemManager;

  })();

  $Model.GemManager = GemManager;

}).call(this);
